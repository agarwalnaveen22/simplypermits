import { Subject, BehaviorSubject, timer, of, combineLatest, EMPTY } from 'rxjs';
import { tap, map, skip, delay, filter, debounce, switchMap, distinctUntilChanged } from 'rxjs/operators';
import { InjectionToken, Injectable, Inject, Optional, NgModule, Component, Input, Output, ChangeDetectionStrategy, EventEmitter, ViewEncapsulation, defineInjectable, inject } from '@angular/core';
import { CommonModule } from '@angular/common';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class NgProgressRef {
    /**
     * @param {?} customConfig
     */
    constructor(customConfig) {
        this._state = { active: false, value: 0 };
        /**
         * Stream that increments and updates progress state
         */
        this._trickling$ = new Subject();
        /**
         * Stream that emits when progress state is changed
         */
        this.state$ = new BehaviorSubject(this._state);
        /**
         * Stream that emits when config is changed
         */
        this.config$ = new Subject();
        combineLatest(this._trickling$, this.config$).pipe(debounce(([start, config]) => timer(start ? this._config.debounceTime : 0)), switchMap(([start, config]) => start ? this._trickling(config) : this._complete(config))).subscribe();
        this.setConfig(customConfig);
    }
    /**
     * @return {?}
     */
    get isStarted() {
        return this._state.active;
    }
    /**
     * Progress start event
     * @return {?}
     */
    get started() {
        return this.state$.pipe(map((state) => state.active), distinctUntilChanged(), filter(active => active));
    }
    /**
     * Progress ended event
     * @return {?}
     */
    get completed() {
        return this.state$.pipe(map((state) => state.active), distinctUntilChanged(), filter(active => !active), skip(1));
    }
    /**
     * @return {?}
     */
    start() {
        this._trickling$.next(true);
    }
    /**
     * @return {?}
     */
    complete() {
        this._trickling$.next(false);
    }
    /**
     * @param {?=} amount
     * @return {?}
     */
    inc(amount) {
        /** @type {?} */
        const n = this._state.value;
        if (!this.isStarted) {
            this.start();
        }
        else {
            if (typeof amount !== 'number') {
                amount = this._config.trickleFunc(n);
            }
            this.set(n + amount);
        }
    }
    /**
     * @param {?} n
     * @return {?}
     */
    set(n) {
        this._setState({ value: this._clamp(n), active: true });
    }
    /**
     * @param {?} config
     * @return {?}
     */
    setConfig(config) {
        this._config = Object.assign({}, this._config, config);
        this.config$.next(this._config);
    }
    /**
     * Meant to be used internally and not by user directly
     * Users should use NgProgressManager.destroy(id) instead
     * @return {?}
     */
    destroy() {
        this._trickling$.complete();
        this.state$.complete();
        this.config$.complete();
    }
    /**
     * @param {?} state
     * @return {?}
     */
    _setState(state) {
        this._state = Object.assign({}, this._state, state);
        this.state$.next(this._state);
    }
    /**
     * Clamps a value to be between min and max
     * @param {?} n
     * @return {?}
     */
    _clamp(n) {
        return Math.max(this._config.min, Math.min(this._config.max, n));
    }
    /**
     * Keeps incrementing the progress
     * @param {?} config
     * @return {?}
     */
    _trickling(config) {
        if (!this.isStarted) {
            this.set(this._config.min);
        }
        return timer(0, config.trickleSpeed).pipe(tap(() => this.inc()));
    }
    /**
     * Completes then resets the progress
     * @param {?} config
     * @return {?}
     */
    _complete(config) {
        return !this.isStarted ? of({}) : of({}).pipe(
        // Completes the progress
        tap(() => this._setState({ value: 100 })), 
        // Hides the progress bar after a tiny delay
        delay(config.speed * 1.7), tap(() => this._setState({ active: false })), 
        // Resets the progress state
        delay(config.speed), tap(() => this._setState({ value: 0 })));
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
const CONFIG = new InjectionToken('config');

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
const ɵ0 = (n) => {
    if (n >= 0 && n < 20)
        return 10;
    if (n >= 20 && n < 50)
        return 4;
    if (n >= 50 && n < 80)
        return 2;
    if (n >= 80 && n < 99)
        return 0.5;
    return 0;
};
/** @type {?} */
const defaultConfig = {
    meteor: true,
    spinner: true,
    thick: false,
    ease: 'linear',
    spinnerPosition: 'right',
    direction: 'ltr+',
    color: '#1B95E0',
    max: 100,
    min: 8,
    speed: 200,
    trickleSpeed: 300,
    debounceTime: 0,
    trickleFunc: ɵ0
};
class NgProgress {
    /**
     * @param {?} config
     */
    constructor(config) {
        /**
         * Stores NgProgressRef instances
         */
        this._instances = {};
        this.config = Object.assign({}, defaultConfig, config);
    }
    /**
     * Returns NgProgressRef by ID
     * @param {?=} id
     * @param {?=} config
     * @return {?}
     */
    ref(id = 'root', config) {
        if (this._instances[id] instanceof NgProgressRef) {
            return this._instances[id];
        }
        else {
            config = Object.assign({}, this.config, config);
            return this._instances[id] = new NgProgressRef(config);
        }
    }
    /**
     * @param {?} config
     * @param {?=} id
     * @return {?}
     */
    setConfig(config, id = 'root') {
        if (this._instances[id] instanceof NgProgressRef) {
            this._instances[id].setConfig(config);
        }
    }
    /**
     * @param {?=} id
     * @return {?}
     */
    start(id = 'root') {
        if (this._instances[id] instanceof NgProgressRef) {
            this._instances[id].start();
        }
    }
    /**
     * @param {?} n
     * @param {?=} id
     * @return {?}
     */
    set(n, id = 'root') {
        if (this._instances[id] instanceof NgProgressRef) {
            this._instances[id].set(n);
        }
    }
    /**
     * @param {?=} n
     * @param {?=} id
     * @return {?}
     */
    inc(n, id = 'root') {
        if (this._instances[id] instanceof NgProgressRef) {
            this._instances[id].inc(n);
        }
    }
    /**
     * @param {?=} id
     * @return {?}
     */
    complete(id = 'root') {
        if (this._instances[id] instanceof NgProgressRef) {
            this._instances[id].complete();
        }
    }
    /**
     * @param {?=} id
     * @return {?}
     */
    isStarted(id = 'root') {
        return (this._instances[id] instanceof NgProgressRef) ? this._instances[id].isStarted : false;
    }
    /**
     * @param {?=} id
     * @return {?}
     */
    started(id = 'root') {
        return (this._instances[id] instanceof NgProgressRef) ? this._instances[id].started : EMPTY;
    }
    /**
     * @param {?=} id
     * @return {?}
     */
    completed(id = 'root') {
        return (this._instances[id] instanceof NgProgressRef) ? this._instances[id].completed : EMPTY;
    }
    /**
     * @param {?=} id
     * @return {?}
     */
    destroy(id = 'root') {
        if (this._instances[id] instanceof NgProgressRef) {
            this._instances[id].destroy();
            this._instances[id] = null;
        }
    }
    /**
     * @return {?}
     */
    destroyAll() {
        Object.keys(this._instances).map((key) => {
            this._instances[key].destroy();
            this._instances[key] = null;
        });
    }
}
NgProgress.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
NgProgress.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [CONFIG,] }] }
];
/** @nocollapse */ NgProgress.ngInjectableDef = defineInjectable({ factory: function NgProgress_Factory() { return new NgProgress(inject(CONFIG, 8)); }, token: NgProgress, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class NgProgressComponent {
    /**
     * @param {?} _ngProgress
     */
    constructor(_ngProgress) {
        this._ngProgress = _ngProgress;
        /**
         * Creates a new instance if id is not already exists
         */
        this.id = 'root';
        /**
         * Initializes inputs from the global config
         */
        this.spinnerPosition = this._ngProgress.config.spinnerPosition;
        this.direction = this._ngProgress.config.direction;
        this.ease = this._ngProgress.config.ease;
        this.color = this._ngProgress.config.color;
        this.meteor = this._ngProgress.config.meteor;
        this.spinner = this._ngProgress.config.spinner;
        this.thick = this._ngProgress.config.thick;
        this.max = this._ngProgress.config.max;
        this.min = this._ngProgress.config.min;
        this.speed = this._ngProgress.config.speed;
        this.trickleSpeed = this._ngProgress.config.trickleSpeed;
        this.trickleFunc = this._ngProgress.config.trickleFunc;
        this.debounceTime = this._ngProgress.config.debounceTime;
        this.started = new EventEmitter();
        this.completed = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnChanges() {
        if (this.progressRef instanceof NgProgressRef) {
            // Update progress bar config when inputs change
            this.progressRef.setConfig({
                max: (this.max > 0 && this.max <= 100) ? this.max : 100,
                min: (this.min < 100 && this.min >= 0) ? this.min : 0,
                speed: this.speed,
                trickleSpeed: this.trickleSpeed,
                trickleFunc: this.trickleFunc,
                debounceTime: this.debounceTime
            });
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        // Get progress bar service instance
        this.progressRef = this._ngProgress.ref(this.id, {
            max: this.max,
            min: this.min,
            speed: this.speed,
            trickleSpeed: this.trickleSpeed,
            debounceTime: this.debounceTime
        });
        this.state$ = this.progressRef.state$.pipe(map((state) => ({
            active: state.active,
            transform: `translate3d(${state.value}%,0,0)`
        })));
        /** Subscribes to started and completed events when user used them */
        if (this.started.observers.length) {
            this._started$ = this.progressRef.started.subscribe(() => this.started.emit());
        }
        if (this.completed.observers.length) {
            this._completed$ = this.progressRef.completed.subscribe(() => this.completed.emit());
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this._started$) {
            this._started$.unsubscribe();
        }
        if (this._completed$) {
            this._completed$.unsubscribe();
        }
        this._ngProgress.destroy(this.id);
    }
    /**
     * @return {?}
     */
    start() {
        this.progressRef.start();
    }
    /**
     * @return {?}
     */
    complete() {
        this.progressRef.complete();
    }
    /**
     * @param {?=} n
     * @return {?}
     */
    inc(n) {
        this.progressRef.inc(n);
    }
    /**
     * @param {?} n
     * @return {?}
     */
    set(n) {
        this.progressRef.set(n);
    }
    /**
     * @return {?}
     */
    get isStarted() {
        return this.progressRef.isStarted;
    }
}
NgProgressComponent.decorators = [
    { type: Component, args: [{
                selector: 'ng-progress',
                host: {
                    'role': 'progressbar',
                    '[attr.spinnerPosition]': 'spinnerPosition',
                    '[attr.dir]': 'direction',
                    '[attr.thick]': 'thick'
                },
                template: `
    <ng-container *ngIf="state$ | async; let state">
      <div class="ng-progress-bar"
            [class.-active]="state.active"
            [style.transition]="'opacity ' + speed + 'ms ' + ease">
        <div class="ng-bar-placeholder">
          <div class="ng-bar"
                [style.transform]="state.transform"
                [style.backgroundColor]="color"
                [style.transition]="state.active ? 'all ' + speed + 'ms ' + ease : 'none'">
            <div *ngIf="meteor" class="ng-meteor" [style.boxShadow]="'0 0 10px '+ color + ', 0 0 5px ' + color"></div>
          </div>
        </div>
        <div *ngIf="spinner" class="ng-spinner">
          <div class="ng-spinner-icon"
                [style.borderTopColor]="color"
                [style.borderLeftColor]="color"></div>
        </div>
      </div>
    </ng-container>
  `,
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush,
                preserveWhitespaces: false,
                styles: ["ng-progress{z-index:999999;pointer-events:none;position:relative}.ng-progress-bar{z-index:999999;top:0;left:0;width:100%;position:fixed;zoom:1;opacity:0}.ng-progress-bar.-active{opacity:1;transition:none}.ng-bar-placeholder{position:absolute;height:2px;width:100%}.ng-bar{width:100%;height:100%;-webkit-transform:translate(-100%,0,0);transform:translate(-100%,0,0)}.ng-meteor{display:block;position:absolute;width:100px;height:100%;opacity:1}.ng-spinner{display:block;position:fixed;z-index:1031;top:15px}.ng-spinner-icon{width:18px;height:18px;box-sizing:border-box;-webkit-animation:.4s linear infinite spinner-animation;animation:.4s linear infinite spinner-animation;border:2px solid transparent;border-radius:50%}[dir='ltr+'] .ng-meteor,[dir=ltr-] .ng-meteor{-webkit-transform:rotate(3deg);transform:rotate(3deg)}[dir='ltr+'][thick=true] .ng-meteor,[dir=ltr-][thick=true] .ng-meteor{-webkit-transform:rotate(4deg);transform:rotate(4deg)}[dir='ltr+'] .ng-bar,[dir='rtl+'] .ng-bar{margin-left:-100%}[dir='ltr+'] .ng-meteor,[dir='rtl+'] .ng-meteor{right:0}[dir='ltr+'] .ng-meteor,[dir=rtl-] .ng-meteor{top:-3px}[dir='ltr+'][thick=true] .ng-meteor,[dir=rtl-][thick=true] .ng-meteor{top:-4px}[dir='rtl+'] .ng-meteor,[dir=ltr-] .ng-meteor{bottom:-3px}[dir='rtl+'][thick=true] .ng-meteor,[dir=ltr-][thick=true] .ng-meteor{bottom:-4px}[dir='rtl+'] .ng-bar-placeholder,[dir=ltr-] .ng-bar-placeholder{-webkit-transform:rotate(180deg);transform:rotate(180deg)}[dir='rtl+'] .ng-spinner-icon,[dir=ltr-] .ng-spinner-icon{animation-direction:reverse}[dir='rtl+'] .ng-meteor,[dir=rtl-] .ng-meteor{-webkit-transform:rotate(-3deg);transform:rotate(-3deg)}[dir='rtl+'][thick=true] .ng-meteor,[dir=rtl-][thick=true] .ng-meteor{-webkit-transform:rotate(-4deg);transform:rotate(-4deg)}[thick=true] .ng-spinner-icon{width:24px;height:24px;border-width:3px}[thick=true] .ng-bar-placeholder{height:3px}[spinnerPosition=left] .ng-spinner{left:15px;right:unset}[spinnerPosition=right] .ng-spinner{right:15px}@-webkit-keyframes spinner-animation{0%{-webkit-transform:rotate(0);transform:rotate(0)}100%{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}@keyframes spinner-animation{0%{-webkit-transform:rotate(0);transform:rotate(0)}100%{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}"]
            }] }
];
/** @nocollapse */
NgProgressComponent.ctorParameters = () => [
    { type: NgProgress }
];
NgProgressComponent.propDecorators = {
    id: [{ type: Input }],
    spinnerPosition: [{ type: Input }],
    direction: [{ type: Input }],
    ease: [{ type: Input }],
    color: [{ type: Input }],
    meteor: [{ type: Input }],
    spinner: [{ type: Input }],
    thick: [{ type: Input }],
    max: [{ type: Input }],
    min: [{ type: Input }],
    speed: [{ type: Input }],
    trickleSpeed: [{ type: Input }],
    trickleFunc: [{ type: Input }],
    debounceTime: [{ type: Input }],
    started: [{ type: Output }],
    completed: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class NgProgressModule {
    /**
     * @param {?=} config
     * @return {?}
     */
    static forRoot(config) {
        return {
            ngModule: NgProgressModule,
            providers: [
                { provide: CONFIG, useValue: config }
            ]
        };
    }
}
NgProgressModule.decorators = [
    { type: NgModule, args: [{
                declarations: [NgProgressComponent],
                exports: [NgProgressComponent],
                imports: [CommonModule]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

export { NgProgressModule, NgProgressComponent, NgProgressRef, NgProgress, CONFIG };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmd4LXByb2dyZXNzYmFyLWNvcmUuanMubWFwIiwic291cmNlcyI6WyJuZzovL0BuZ3gtcHJvZ3Jlc3NiYXIvY29yZS9saWIvbmctcHJvZ3Jlc3MtcmVmLnRzIiwibmc6Ly9Abmd4LXByb2dyZXNzYmFyL2NvcmUvbGliL25nLXByb2dyZXNzLmludGVyZmFjZS50cyIsIm5nOi8vQG5neC1wcm9ncmVzc2Jhci9jb3JlL2xpYi9uZy1wcm9ncmVzcy5zZXJ2aWNlLnRzIiwibmc6Ly9Abmd4LXByb2dyZXNzYmFyL2NvcmUvbGliL25nLXByb2dyZXNzLmNvbXBvbmVudC50cyIsIm5nOi8vQG5neC1wcm9ncmVzc2Jhci9jb3JlL2xpYi9uZy1wcm9ncmVzcy5tb2R1bGUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTmdQcm9ncmVzc1N0YXRlLCBOZ1Byb2dyZXNzQ29uZmlnIH0gZnJvbSAnLi9uZy1wcm9ncmVzcy5pbnRlcmZhY2UnO1xyXG5pbXBvcnQgeyBPYnNlcnZhYmxlLCBTdWJqZWN0LCBCZWhhdmlvclN1YmplY3QsIHRpbWVyLCBvZiwgY29tYmluZUxhdGVzdCB9IGZyb20gJ3J4anMnO1xyXG5pbXBvcnQgeyB0YXAsIG1hcCwgc2tpcCwgZGVsYXksIGZpbHRlciwgZGVib3VuY2UsIHN3aXRjaE1hcCwgZGlzdGluY3RVbnRpbENoYW5nZWQgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XHJcblxyXG5leHBvcnQgY2xhc3MgTmdQcm9ncmVzc1JlZiB7XHJcblxyXG4gIHByaXZhdGUgX3N0YXRlOiBOZ1Byb2dyZXNzU3RhdGUgPSB7YWN0aXZlOiBmYWxzZSwgdmFsdWU6IDB9O1xyXG4gIHByaXZhdGUgX2NvbmZpZzogTmdQcm9ncmVzc0NvbmZpZztcclxuXHJcbiAgLyoqIFN0cmVhbSB0aGF0IGluY3JlbWVudHMgYW5kIHVwZGF0ZXMgcHJvZ3Jlc3Mgc3RhdGUgKi9cclxuICBwcml2YXRlIF90cmlja2xpbmckID0gbmV3IFN1YmplY3QoKTtcclxuXHJcbiAgLyoqIFN0cmVhbSB0aGF0IGVtaXRzIHdoZW4gcHJvZ3Jlc3Mgc3RhdGUgaXMgY2hhbmdlZCAqL1xyXG4gIHN0YXRlJCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8TmdQcm9ncmVzc1N0YXRlPih0aGlzLl9zdGF0ZSk7XHJcblxyXG4gIC8qKiBTdHJlYW0gdGhhdCBlbWl0cyB3aGVuIGNvbmZpZyBpcyBjaGFuZ2VkICovXHJcbiAgY29uZmlnJCA9IG5ldyBTdWJqZWN0PE5nUHJvZ3Jlc3NDb25maWc+KCk7XHJcblxyXG4gIGdldCBpc1N0YXJ0ZWQoKTogYm9vbGVhbiB7XHJcbiAgICByZXR1cm4gdGhpcy5fc3RhdGUuYWN0aXZlO1xyXG4gIH1cclxuXHJcbiAgLyoqIFByb2dyZXNzIHN0YXJ0IGV2ZW50ICovXHJcbiAgZ2V0IHN0YXJ0ZWQoKTogT2JzZXJ2YWJsZTxib29sZWFuPiB7XHJcbiAgICByZXR1cm4gdGhpcy5zdGF0ZSQucGlwZShcclxuICAgICAgbWFwKChzdGF0ZTogTmdQcm9ncmVzc1N0YXRlKSA9PiBzdGF0ZS5hY3RpdmUpLFxyXG4gICAgICBkaXN0aW5jdFVudGlsQ2hhbmdlZCgpLFxyXG4gICAgICBmaWx0ZXIoYWN0aXZlID0+IGFjdGl2ZSlcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICAvKiogUHJvZ3Jlc3MgZW5kZWQgZXZlbnQgKi9cclxuICBnZXQgY29tcGxldGVkKCk6IE9ic2VydmFibGU8Ym9vbGVhbj4ge1xyXG4gICAgcmV0dXJuIHRoaXMuc3RhdGUkLnBpcGUoXHJcbiAgICAgIG1hcCgoc3RhdGU6IE5nUHJvZ3Jlc3NTdGF0ZSkgPT4gc3RhdGUuYWN0aXZlKSxcclxuICAgICAgZGlzdGluY3RVbnRpbENoYW5nZWQoKSxcclxuICAgICAgZmlsdGVyKGFjdGl2ZSA9PiAhYWN0aXZlKSxcclxuICAgICAgc2tpcCgxKVxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIGNvbnN0cnVjdG9yKGN1c3RvbUNvbmZpZzogTmdQcm9ncmVzc0NvbmZpZykge1xyXG5cclxuICAgIGNvbWJpbmVMYXRlc3QodGhpcy5fdHJpY2tsaW5nJCwgdGhpcy5jb25maWckKS5waXBlKFxyXG4gICAgICBkZWJvdW5jZSgoW3N0YXJ0LCBjb25maWddOiBbYm9vbGVhbiwgTmdQcm9ncmVzc0NvbmZpZ10pID0+IHRpbWVyKHN0YXJ0ID8gdGhpcy5fY29uZmlnLmRlYm91bmNlVGltZSA6IDApKSxcclxuICAgICAgc3dpdGNoTWFwKChbc3RhcnQsIGNvbmZpZ106IFtib29sZWFuLCBOZ1Byb2dyZXNzQ29uZmlnXSkgPT4gc3RhcnQgPyB0aGlzLl90cmlja2xpbmcoY29uZmlnKSA6IHRoaXMuX2NvbXBsZXRlKGNvbmZpZykpXHJcbiAgICApLnN1YnNjcmliZSgpO1xyXG5cclxuICAgIHRoaXMuc2V0Q29uZmlnKGN1c3RvbUNvbmZpZyk7XHJcbiAgfVxyXG5cclxuICBzdGFydCgpIHtcclxuICAgIHRoaXMuX3RyaWNrbGluZyQubmV4dCh0cnVlKTtcclxuICB9XHJcblxyXG4gIGNvbXBsZXRlKCkge1xyXG4gICAgdGhpcy5fdHJpY2tsaW5nJC5uZXh0KGZhbHNlKTtcclxuICB9XHJcblxyXG4gIGluYyhhbW91bnQ/OiBudW1iZXIpIHtcclxuICAgIGNvbnN0IG4gPSB0aGlzLl9zdGF0ZS52YWx1ZTtcclxuICAgIGlmICghdGhpcy5pc1N0YXJ0ZWQpIHtcclxuICAgICAgdGhpcy5zdGFydCgpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaWYgKHR5cGVvZiBhbW91bnQgIT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgYW1vdW50ID0gdGhpcy5fY29uZmlnLnRyaWNrbGVGdW5jKG4pO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuc2V0KG4gKyBhbW91bnQpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgc2V0KG46IG51bWJlcikge1xyXG4gICAgdGhpcy5fc2V0U3RhdGUoe3ZhbHVlOiB0aGlzLl9jbGFtcChuKSwgYWN0aXZlOiB0cnVlfSk7XHJcbiAgfVxyXG5cclxuICBzZXRDb25maWcoY29uZmlnOiBOZ1Byb2dyZXNzQ29uZmlnKSB7XHJcbiAgICB0aGlzLl9jb25maWcgPSB7Li4udGhpcy5fY29uZmlnLCAuLi5jb25maWd9O1xyXG4gICAgdGhpcy5jb25maWckLm5leHQodGhpcy5fY29uZmlnKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE1lYW50IHRvIGJlIHVzZWQgaW50ZXJuYWxseSBhbmQgbm90IGJ5IHVzZXIgZGlyZWN0bHlcclxuICAgKiBVc2VycyBzaG91bGQgdXNlIE5nUHJvZ3Jlc3NNYW5hZ2VyLmRlc3Ryb3koaWQpIGluc3RlYWRcclxuICAgKi9cclxuICBkZXN0cm95KCkge1xyXG4gICAgdGhpcy5fdHJpY2tsaW5nJC5jb21wbGV0ZSgpO1xyXG4gICAgdGhpcy5zdGF0ZSQuY29tcGxldGUoKTtcclxuICAgIHRoaXMuY29uZmlnJC5jb21wbGV0ZSgpO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBfc2V0U3RhdGUoc3RhdGU6IE5nUHJvZ3Jlc3NTdGF0ZSkge1xyXG4gICAgdGhpcy5fc3RhdGUgPSB7Li4udGhpcy5fc3RhdGUsIC4uLnN0YXRlfTtcclxuICAgIHRoaXMuc3RhdGUkLm5leHQodGhpcy5fc3RhdGUpO1xyXG4gIH1cclxuXHJcbiAgLyoqIENsYW1wcyBhIHZhbHVlIHRvIGJlIGJldHdlZW4gbWluIGFuZCBtYXggKi9cclxuICBwcml2YXRlIF9jbGFtcChuKTogbnVtYmVyIHtcclxuICAgIHJldHVybiBNYXRoLm1heCh0aGlzLl9jb25maWcubWluLCBNYXRoLm1pbih0aGlzLl9jb25maWcubWF4LCBuKSk7XHJcbiAgfVxyXG5cclxuICAvKiogS2VlcHMgaW5jcmVtZW50aW5nIHRoZSBwcm9ncmVzcyAqL1xyXG4gIHByaXZhdGUgX3RyaWNrbGluZyhjb25maWc6IE5nUHJvZ3Jlc3NDb25maWcpIHtcclxuICAgIGlmICghdGhpcy5pc1N0YXJ0ZWQpIHtcclxuICAgICAgdGhpcy5zZXQodGhpcy5fY29uZmlnLm1pbik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGltZXIoMCwgY29uZmlnLnRyaWNrbGVTcGVlZCkucGlwZSh0YXAoKCkgPT4gdGhpcy5pbmMoKSkpO1xyXG4gIH1cclxuXHJcbiAgLyoqIENvbXBsZXRlcyB0aGVuIHJlc2V0cyB0aGUgcHJvZ3Jlc3MgKi9cclxuICBwcml2YXRlIF9jb21wbGV0ZShjb25maWc6IE5nUHJvZ3Jlc3NDb25maWcpIHtcclxuICAgIHJldHVybiAhdGhpcy5pc1N0YXJ0ZWQgPyBvZih7fSkgOiBvZih7fSkucGlwZShcclxuICAgICAgLy8gQ29tcGxldGVzIHRoZSBwcm9ncmVzc1xyXG4gICAgICB0YXAoKCkgPT4gdGhpcy5fc2V0U3RhdGUoe3ZhbHVlOiAxMDB9KSksXHJcblxyXG4gICAgICAvLyBIaWRlcyB0aGUgcHJvZ3Jlc3MgYmFyIGFmdGVyIGEgdGlueSBkZWxheVxyXG4gICAgICBkZWxheShjb25maWcuc3BlZWQgKiAxLjcpLFxyXG4gICAgICB0YXAoKCkgPT4gdGhpcy5fc2V0U3RhdGUoe2FjdGl2ZTogZmFsc2V9KSksXHJcblxyXG4gICAgICAvLyBSZXNldHMgdGhlIHByb2dyZXNzIHN0YXRlXHJcbiAgICAgIGRlbGF5KGNvbmZpZy5zcGVlZCksXHJcbiAgICAgIHRhcCgoKSA9PiB0aGlzLl9zZXRTdGF0ZSh7dmFsdWU6IDB9KSlcclxuICAgICk7XHJcbiAgfVxyXG59XHJcbiIsImltcG9ydCB7IEluamVjdGlvblRva2VuIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIE5nUHJvZ3Jlc3NTdGF0ZSB7XHJcbiAgYWN0aXZlPzogYm9vbGVhbjtcclxuICB2YWx1ZT86IG51bWJlcjtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBOZ1Byb2dyZXNzQ29uZmlnIHtcclxuICBzcGlubmVyUG9zaXRpb24/OiAnbGVmdCcgfCAncmlnaHQnO1xyXG4gIGRpcmVjdGlvbj86ICdsdHIrJyB8ICdsdHItJyB8ICdydGwrJyB8ICdydGwtJztcclxuICBlYXNlPzogc3RyaW5nO1xyXG4gIGNvbG9yPzogc3RyaW5nO1xyXG4gIHRoaWNrPzogYm9vbGVhbjtcclxuICBtZXRlb3I/OiBib29sZWFuO1xyXG4gIHNwaW5uZXI/OiBib29sZWFuO1xyXG4gIG1heD86IG51bWJlcjtcclxuICBtaW4/OiBudW1iZXI7XHJcbiAgc3BlZWQ/OiBudW1iZXI7XHJcbiAgdHJpY2tsZVNwZWVkPzogbnVtYmVyO1xyXG4gIHRyaWNrbGVGdW5jPzogKG46IG51bWJlcikgPT4gbnVtYmVyO1xyXG4gIGRlYm91bmNlVGltZT86IG51bWJlcjtcclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IENPTkZJRyA9IG5ldyBJbmplY3Rpb25Ub2tlbjxOZ1Byb2dyZXNzQ29uZmlnPignY29uZmlnJyk7XHJcbiIsImltcG9ydCB7IEluamVjdGFibGUsIEluamVjdCwgT3B0aW9uYWwgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgRU1QVFkgfSBmcm9tICdyeGpzJztcclxuaW1wb3J0IHsgTmdQcm9ncmVzc1JlZiB9IGZyb20gJy4vbmctcHJvZ3Jlc3MtcmVmJztcclxuaW1wb3J0IHsgTmdQcm9ncmVzc0NvbmZpZywgQ09ORklHIH0gZnJvbSAnLi9uZy1wcm9ncmVzcy5pbnRlcmZhY2UnO1xyXG5cclxuY29uc3QgZGVmYXVsdENvbmZpZzogTmdQcm9ncmVzc0NvbmZpZyA9IHtcclxuICBtZXRlb3I6IHRydWUsXHJcbiAgc3Bpbm5lcjogdHJ1ZSxcclxuICB0aGljazogZmFsc2UsXHJcbiAgZWFzZTogJ2xpbmVhcicsXHJcbiAgc3Bpbm5lclBvc2l0aW9uOiAncmlnaHQnLFxyXG4gIGRpcmVjdGlvbjogJ2x0cisnLFxyXG4gIGNvbG9yOiAnIzFCOTVFMCcsXHJcbiAgbWF4OiAxMDAsXHJcbiAgbWluOiA4LFxyXG4gIHNwZWVkOiAyMDAsXHJcbiAgdHJpY2tsZVNwZWVkOiAzMDAsXHJcbiAgZGVib3VuY2VUaW1lOiAwLFxyXG4gIHRyaWNrbGVGdW5jOiAobjogbnVtYmVyKTogbnVtYmVyID0+IHtcclxuICAgIGlmIChuID49IDAgJiYgbiA8IDIwKSByZXR1cm4gMTA7XHJcbiAgICBpZiAobiA+PSAyMCAmJiBuIDwgNTApIHJldHVybiA0O1xyXG4gICAgaWYgKG4gPj0gNTAgJiYgbiA8IDgwKSByZXR1cm4gMjtcclxuICAgIGlmIChuID49IDgwICYmIG4gPCA5OSkgcmV0dXJuIDAuNTtcclxuICAgIHJldHVybiAwO1xyXG4gIH1cclxufTtcclxuXHJcbkBJbmplY3RhYmxlKHtcclxuICBwcm92aWRlZEluOiAncm9vdCdcclxufSlcclxuZXhwb3J0IGNsYXNzIE5nUHJvZ3Jlc3Mge1xyXG5cclxuICAvKiogU3RvcmVzIE5nUHJvZ3Jlc3NSZWYgaW5zdGFuY2VzICovXHJcbiAgcHJpdmF0ZSByZWFkb25seSBfaW5zdGFuY2VzID0ge307XHJcblxyXG4gIC8qKiBHbG9iYWwgY29uZmlnICovXHJcbiAgY29uZmlnOiBOZ1Byb2dyZXNzQ29uZmlnO1xyXG5cclxuICBjb25zdHJ1Y3RvcihAT3B0aW9uYWwoKSBASW5qZWN0KENPTkZJRykgY29uZmlnOiBOZ1Byb2dyZXNzQ29uZmlnKSB7XHJcbiAgICB0aGlzLmNvbmZpZyA9IHsuLi5kZWZhdWx0Q29uZmlnLCAuLi5jb25maWd9O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBOZ1Byb2dyZXNzUmVmIGJ5IElEXHJcbiAgICovXHJcbiAgcmVmKGlkID0gJ3Jvb3QnLCBjb25maWc/OiBOZ1Byb2dyZXNzQ29uZmlnKSB7XHJcbiAgICBpZiAodGhpcy5faW5zdGFuY2VzW2lkXSBpbnN0YW5jZW9mIE5nUHJvZ3Jlc3NSZWYpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuX2luc3RhbmNlc1tpZF07XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjb25maWcgPSB7Li4udGhpcy5jb25maWcsIC4uLmNvbmZpZ307XHJcbiAgICAgIHJldHVybiB0aGlzLl9pbnN0YW5jZXNbaWRdID0gbmV3IE5nUHJvZ3Jlc3NSZWYoY29uZmlnKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHNldENvbmZpZyhjb25maWc6IE5nUHJvZ3Jlc3NDb25maWcsIGlkID0gJ3Jvb3QnKSB7XHJcbiAgICBpZiAodGhpcy5faW5zdGFuY2VzW2lkXSBpbnN0YW5jZW9mIE5nUHJvZ3Jlc3NSZWYpIHtcclxuICAgICAgdGhpcy5faW5zdGFuY2VzW2lkXS5zZXRDb25maWcoY29uZmlnKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHN0YXJ0KGlkID0gJ3Jvb3QnKSB7XHJcbiAgICBpZiAodGhpcy5faW5zdGFuY2VzW2lkXSBpbnN0YW5jZW9mIE5nUHJvZ3Jlc3NSZWYpIHtcclxuICAgICAgdGhpcy5faW5zdGFuY2VzW2lkXS5zdGFydCgpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgc2V0KG46IG51bWJlciwgaWQgPSAncm9vdCcpIHtcclxuICAgIGlmICh0aGlzLl9pbnN0YW5jZXNbaWRdIGluc3RhbmNlb2YgTmdQcm9ncmVzc1JlZikge1xyXG4gICAgICB0aGlzLl9pbnN0YW5jZXNbaWRdLnNldChuKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGluYyhuPzogbnVtYmVyLCBpZCA9ICdyb290Jykge1xyXG4gICAgaWYgKHRoaXMuX2luc3RhbmNlc1tpZF0gaW5zdGFuY2VvZiBOZ1Byb2dyZXNzUmVmKSB7XHJcbiAgICAgIHRoaXMuX2luc3RhbmNlc1tpZF0uaW5jKG4pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgY29tcGxldGUoaWQgPSAncm9vdCcpIHtcclxuICAgIGlmICh0aGlzLl9pbnN0YW5jZXNbaWRdIGluc3RhbmNlb2YgTmdQcm9ncmVzc1JlZikge1xyXG4gICAgICB0aGlzLl9pbnN0YW5jZXNbaWRdLmNvbXBsZXRlKCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBpc1N0YXJ0ZWQoaWQgPSAncm9vdCcpIHtcclxuICAgIHJldHVybiAodGhpcy5faW5zdGFuY2VzW2lkXSBpbnN0YW5jZW9mIE5nUHJvZ3Jlc3NSZWYpID8gdGhpcy5faW5zdGFuY2VzW2lkXS5pc1N0YXJ0ZWQgOiBmYWxzZTtcclxuICB9XHJcblxyXG4gIHN0YXJ0ZWQoaWQgPSAncm9vdCcpIHtcclxuICAgIHJldHVybiAodGhpcy5faW5zdGFuY2VzW2lkXSBpbnN0YW5jZW9mIE5nUHJvZ3Jlc3NSZWYpID8gdGhpcy5faW5zdGFuY2VzW2lkXS5zdGFydGVkIDogRU1QVFk7XHJcbiAgfVxyXG5cclxuICBjb21wbGV0ZWQoaWQgPSAncm9vdCcpIHtcclxuICAgIHJldHVybiAodGhpcy5faW5zdGFuY2VzW2lkXSBpbnN0YW5jZW9mIE5nUHJvZ3Jlc3NSZWYpID8gdGhpcy5faW5zdGFuY2VzW2lkXS5jb21wbGV0ZWQgOiBFTVBUWTtcclxuICB9XHJcblxyXG4gIGRlc3Ryb3koaWQgPSAncm9vdCcpIHtcclxuICAgIGlmICh0aGlzLl9pbnN0YW5jZXNbaWRdIGluc3RhbmNlb2YgTmdQcm9ncmVzc1JlZikge1xyXG4gICAgICB0aGlzLl9pbnN0YW5jZXNbaWRdLmRlc3Ryb3koKTtcclxuICAgICAgdGhpcy5faW5zdGFuY2VzW2lkXSA9IG51bGw7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBkZXN0cm95QWxsKCkge1xyXG4gICAgT2JqZWN0LmtleXModGhpcy5faW5zdGFuY2VzKS5tYXAoKGtleSkgPT4ge1xyXG4gICAgICB0aGlzLl9pbnN0YW5jZXNba2V5XS5kZXN0cm95KCk7XHJcbiAgICAgIHRoaXMuX2luc3RhbmNlc1trZXldID0gbnVsbDtcclxuICAgIH0pO1xyXG4gIH1cclxufVxyXG4iLCIvKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IG5neC1wcm9ncmVzc2JhciBBbGwgUmlnaHRzIFJlc2VydmVkLlxyXG4gKlxyXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxyXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vZ2l0aHViLmNvbS9NdXJoYWZTb3VzbGkvbmd4LXByb2dyZXNzYmFyL2Jsb2IvbWFzdGVyL0xJQ0VOU0VcclxuICovXHJcblxyXG5pbXBvcnQge1xyXG4gIENvbXBvbmVudCxcclxuICBJbnB1dCxcclxuICBPbkNoYW5nZXMsXHJcbiAgT25EZXN0cm95LFxyXG4gIE9uSW5pdCxcclxuICBPdXRwdXQsXHJcbiAgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksXHJcbiAgRXZlbnRFbWl0dGVyLFxyXG4gIFZpZXdFbmNhcHN1bGF0aW9uXHJcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IE5nUHJvZ3Jlc3MgfSBmcm9tICcuL25nLXByb2dyZXNzLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBOZ1Byb2dyZXNzUmVmIH0gZnJvbSAnLi9uZy1wcm9ncmVzcy1yZWYnO1xyXG5pbXBvcnQgeyBOZ1Byb2dyZXNzU3RhdGUgfSBmcm9tICcuL25nLXByb2dyZXNzLmludGVyZmFjZSc7XHJcbmltcG9ydCB7IE9ic2VydmFibGUsIFN1YnNjcmlwdGlvbn0gZnJvbSAncnhqcyc7XHJcbmltcG9ydCB7IG1hcCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcclxuXHJcbkBDb21wb25lbnQoe1xyXG4gIHNlbGVjdG9yOiAnbmctcHJvZ3Jlc3MnLFxyXG4gIGhvc3Q6IHtcclxuICAgICdyb2xlJzogJ3Byb2dyZXNzYmFyJyxcclxuICAgICdbYXR0ci5zcGlubmVyUG9zaXRpb25dJzogJ3NwaW5uZXJQb3NpdGlvbicsXHJcbiAgICAnW2F0dHIuZGlyXSc6ICdkaXJlY3Rpb24nLFxyXG4gICAgJ1thdHRyLnRoaWNrXSc6ICd0aGljaydcclxuICB9LFxyXG4gIHRlbXBsYXRlOiBgXHJcbiAgICA8bmctY29udGFpbmVyICpuZ0lmPVwic3RhdGUkIHwgYXN5bmM7IGxldCBzdGF0ZVwiPlxyXG4gICAgICA8ZGl2IGNsYXNzPVwibmctcHJvZ3Jlc3MtYmFyXCJcclxuICAgICAgICAgICAgW2NsYXNzLi1hY3RpdmVdPVwic3RhdGUuYWN0aXZlXCJcclxuICAgICAgICAgICAgW3N0eWxlLnRyYW5zaXRpb25dPVwiJ29wYWNpdHkgJyArIHNwZWVkICsgJ21zICcgKyBlYXNlXCI+XHJcbiAgICAgICAgPGRpdiBjbGFzcz1cIm5nLWJhci1wbGFjZWhvbGRlclwiPlxyXG4gICAgICAgICAgPGRpdiBjbGFzcz1cIm5nLWJhclwiXHJcbiAgICAgICAgICAgICAgICBbc3R5bGUudHJhbnNmb3JtXT1cInN0YXRlLnRyYW5zZm9ybVwiXHJcbiAgICAgICAgICAgICAgICBbc3R5bGUuYmFja2dyb3VuZENvbG9yXT1cImNvbG9yXCJcclxuICAgICAgICAgICAgICAgIFtzdHlsZS50cmFuc2l0aW9uXT1cInN0YXRlLmFjdGl2ZSA/ICdhbGwgJyArIHNwZWVkICsgJ21zICcgKyBlYXNlIDogJ25vbmUnXCI+XHJcbiAgICAgICAgICAgIDxkaXYgKm5nSWY9XCJtZXRlb3JcIiBjbGFzcz1cIm5nLW1ldGVvclwiIFtzdHlsZS5ib3hTaGFkb3ddPVwiJzAgMCAxMHB4ICcrIGNvbG9yICsgJywgMCAwIDVweCAnICsgY29sb3JcIj48L2Rpdj5cclxuICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDxkaXYgKm5nSWY9XCJzcGlubmVyXCIgY2xhc3M9XCJuZy1zcGlubmVyXCI+XHJcbiAgICAgICAgICA8ZGl2IGNsYXNzPVwibmctc3Bpbm5lci1pY29uXCJcclxuICAgICAgICAgICAgICAgIFtzdHlsZS5ib3JkZXJUb3BDb2xvcl09XCJjb2xvclwiXHJcbiAgICAgICAgICAgICAgICBbc3R5bGUuYm9yZGVyTGVmdENvbG9yXT1cImNvbG9yXCI+PC9kaXY+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICAgIDwvZGl2PlxyXG4gICAgPC9uZy1jb250YWluZXI+XHJcbiAgYCxcclxuICBzdHlsZVVybHM6IFsnLi9uZy1wcm9ncmVzcy5jb21wb25lbnQuc2NzcyddLFxyXG4gIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXHJcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXHJcbiAgcHJlc2VydmVXaGl0ZXNwYWNlczogZmFsc2VcclxufSlcclxuXHJcbmV4cG9ydCBjbGFzcyBOZ1Byb2dyZXNzQ29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0LCBPbkNoYW5nZXMsIE9uRGVzdHJveSB7XHJcblxyXG4gIHByaXZhdGUgX3N0YXJ0ZWQkOiBTdWJzY3JpcHRpb247XHJcbiAgcHJpdmF0ZSBfY29tcGxldGVkJDogU3Vic2NyaXB0aW9uO1xyXG5cclxuICAvKiogUHJvZ3Jlc3MgYmFyIHdvcmtlciAqL1xyXG4gIHByb2dyZXNzUmVmOiBOZ1Byb2dyZXNzUmVmO1xyXG5cclxuICAvKiogUHJvZ3Jlc3Mgc3RhdGUgc3RyZWFtICovXHJcbiAgc3RhdGUkOiBPYnNlcnZhYmxlPHsgYWN0aXZlOiBib29sZWFuLCB0cmFuc2Zvcm06IHN0cmluZyB9PjtcclxuXHJcbiAgLyoqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2UgaWYgaWQgaXMgbm90IGFscmVhZHkgZXhpc3RzICovXHJcbiAgQElucHV0KCkgaWQgPSAncm9vdCc7XHJcblxyXG4gIC8qKiBJbml0aWFsaXplcyBpbnB1dHMgZnJvbSB0aGUgZ2xvYmFsIGNvbmZpZyAqL1xyXG4gIEBJbnB1dCgpIHNwaW5uZXJQb3NpdGlvbjogJ2xlZnQnIHwgJ3JpZ2h0JyA9IHRoaXMuX25nUHJvZ3Jlc3MuY29uZmlnLnNwaW5uZXJQb3NpdGlvbjtcclxuICBASW5wdXQoKSBkaXJlY3Rpb246ICdsdHIrJyB8ICdsdHItJyB8ICdydGwrJyB8ICdydGwtJyA9IHRoaXMuX25nUHJvZ3Jlc3MuY29uZmlnLmRpcmVjdGlvbjtcclxuICBASW5wdXQoKSBlYXNlOiBzdHJpbmcgPSB0aGlzLl9uZ1Byb2dyZXNzLmNvbmZpZy5lYXNlO1xyXG4gIEBJbnB1dCgpIGNvbG9yOiBzdHJpbmcgPSB0aGlzLl9uZ1Byb2dyZXNzLmNvbmZpZy5jb2xvcjtcclxuICBASW5wdXQoKSBtZXRlb3I6IGJvb2xlYW4gPSB0aGlzLl9uZ1Byb2dyZXNzLmNvbmZpZy5tZXRlb3I7XHJcbiAgQElucHV0KCkgc3Bpbm5lcjogYm9vbGVhbiA9IHRoaXMuX25nUHJvZ3Jlc3MuY29uZmlnLnNwaW5uZXI7XHJcbiAgQElucHV0KCkgdGhpY2s6IGJvb2xlYW4gPSB0aGlzLl9uZ1Byb2dyZXNzLmNvbmZpZy50aGljaztcclxuICBASW5wdXQoKSBtYXg6IG51bWJlciA9IHRoaXMuX25nUHJvZ3Jlc3MuY29uZmlnLm1heDtcclxuICBASW5wdXQoKSBtaW46IG51bWJlciA9IHRoaXMuX25nUHJvZ3Jlc3MuY29uZmlnLm1pbjtcclxuICBASW5wdXQoKSBzcGVlZDogbnVtYmVyID0gdGhpcy5fbmdQcm9ncmVzcy5jb25maWcuc3BlZWQ7XHJcbiAgQElucHV0KCkgdHJpY2tsZVNwZWVkOiBudW1iZXIgPSB0aGlzLl9uZ1Byb2dyZXNzLmNvbmZpZy50cmlja2xlU3BlZWQ7XHJcbiAgQElucHV0KCkgdHJpY2tsZUZ1bmM6IChuOiBudW1iZXIpID0+IG51bWJlciA9IHRoaXMuX25nUHJvZ3Jlc3MuY29uZmlnLnRyaWNrbGVGdW5jO1xyXG4gIEBJbnB1dCgpIGRlYm91bmNlVGltZTogbnVtYmVyID0gdGhpcy5fbmdQcm9ncmVzcy5jb25maWcuZGVib3VuY2VUaW1lO1xyXG4gIEBPdXRwdXQoKSBzdGFydGVkID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gIEBPdXRwdXQoKSBjb21wbGV0ZWQgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcblxyXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgX25nUHJvZ3Jlc3M6IE5nUHJvZ3Jlc3MpIHtcclxuICB9XHJcblxyXG4gIG5nT25DaGFuZ2VzKCkge1xyXG4gICAgaWYgKHRoaXMucHJvZ3Jlc3NSZWYgaW5zdGFuY2VvZiBOZ1Byb2dyZXNzUmVmKSB7XHJcbiAgICAgIC8vIFVwZGF0ZSBwcm9ncmVzcyBiYXIgY29uZmlnIHdoZW4gaW5wdXRzIGNoYW5nZVxyXG4gICAgICB0aGlzLnByb2dyZXNzUmVmLnNldENvbmZpZyh7XHJcbiAgICAgICAgbWF4OiAodGhpcy5tYXggPiAwICYmIHRoaXMubWF4IDw9IDEwMCkgPyB0aGlzLm1heCA6IDEwMCxcclxuICAgICAgICBtaW46ICh0aGlzLm1pbiA8IDEwMCAmJiB0aGlzLm1pbiA+PSAwKSA/IHRoaXMubWluIDogMCxcclxuICAgICAgICBzcGVlZDogdGhpcy5zcGVlZCxcclxuICAgICAgICB0cmlja2xlU3BlZWQ6IHRoaXMudHJpY2tsZVNwZWVkLFxyXG4gICAgICAgIHRyaWNrbGVGdW5jOiB0aGlzLnRyaWNrbGVGdW5jLFxyXG4gICAgICAgIGRlYm91bmNlVGltZTogdGhpcy5kZWJvdW5jZVRpbWVcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBuZ09uSW5pdCgpIHtcclxuICAgIC8vIEdldCBwcm9ncmVzcyBiYXIgc2VydmljZSBpbnN0YW5jZVxyXG4gICAgdGhpcy5wcm9ncmVzc1JlZiA9IHRoaXMuX25nUHJvZ3Jlc3MucmVmKHRoaXMuaWQsIHtcclxuICAgICAgbWF4OiB0aGlzLm1heCxcclxuICAgICAgbWluOiB0aGlzLm1pbixcclxuICAgICAgc3BlZWQ6IHRoaXMuc3BlZWQsXHJcbiAgICAgIHRyaWNrbGVTcGVlZDogdGhpcy50cmlja2xlU3BlZWQsXHJcbiAgICAgIGRlYm91bmNlVGltZTogdGhpcy5kZWJvdW5jZVRpbWVcclxuICAgIH0pO1xyXG4gICAgdGhpcy5zdGF0ZSQgPSB0aGlzLnByb2dyZXNzUmVmLnN0YXRlJC5waXBlKG1hcCgoc3RhdGU6IE5nUHJvZ3Jlc3NTdGF0ZSkgPT4gKHtcclxuICAgICAgYWN0aXZlOiBzdGF0ZS5hY3RpdmUsXHJcbiAgICAgIHRyYW5zZm9ybTogYHRyYW5zbGF0ZTNkKCR7c3RhdGUudmFsdWV9JSwwLDApYFxyXG4gICAgfSkpKTtcclxuICAgIC8qKiBTdWJzY3JpYmVzIHRvIHN0YXJ0ZWQgYW5kIGNvbXBsZXRlZCBldmVudHMgd2hlbiB1c2VyIHVzZWQgdGhlbSAqL1xyXG4gICAgaWYgKHRoaXMuc3RhcnRlZC5vYnNlcnZlcnMubGVuZ3RoKSB7XHJcbiAgICAgIHRoaXMuX3N0YXJ0ZWQkID0gdGhpcy5wcm9ncmVzc1JlZi5zdGFydGVkLnN1YnNjcmliZSgoKSA9PiB0aGlzLnN0YXJ0ZWQuZW1pdCgpKTtcclxuICAgIH1cclxuICAgIGlmICh0aGlzLmNvbXBsZXRlZC5vYnNlcnZlcnMubGVuZ3RoKSB7XHJcbiAgICAgIHRoaXMuX2NvbXBsZXRlZCQgPSB0aGlzLnByb2dyZXNzUmVmLmNvbXBsZXRlZC5zdWJzY3JpYmUoKCkgPT4gdGhpcy5jb21wbGV0ZWQuZW1pdCgpKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIG5nT25EZXN0cm95KCkge1xyXG4gICAgaWYgKHRoaXMuX3N0YXJ0ZWQkKSB7XHJcbiAgICAgIHRoaXMuX3N0YXJ0ZWQkLnVuc3Vic2NyaWJlKCk7XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5fY29tcGxldGVkJCkge1xyXG4gICAgICB0aGlzLl9jb21wbGV0ZWQkLnVuc3Vic2NyaWJlKCk7XHJcbiAgICB9XHJcbiAgICB0aGlzLl9uZ1Byb2dyZXNzLmRlc3Ryb3kodGhpcy5pZCk7XHJcbiAgfVxyXG5cclxuICBzdGFydCgpIHtcclxuICAgIHRoaXMucHJvZ3Jlc3NSZWYuc3RhcnQoKTtcclxuICB9XHJcblxyXG4gIGNvbXBsZXRlKCkge1xyXG4gICAgdGhpcy5wcm9ncmVzc1JlZi5jb21wbGV0ZSgpO1xyXG4gIH1cclxuXHJcbiAgaW5jKG4/OiBudW1iZXIpIHtcclxuICAgIHRoaXMucHJvZ3Jlc3NSZWYuaW5jKG4pO1xyXG4gIH1cclxuXHJcbiAgc2V0KG46IG51bWJlcikge1xyXG4gICAgdGhpcy5wcm9ncmVzc1JlZi5zZXQobik7XHJcbiAgfVxyXG5cclxuICBnZXQgaXNTdGFydGVkKCkge1xyXG4gICAgcmV0dXJuIHRoaXMucHJvZ3Jlc3NSZWYuaXNTdGFydGVkO1xyXG4gIH1cclxufVxyXG4iLCJpbXBvcnQgeyBNb2R1bGVXaXRoUHJvdmlkZXJzLCBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xyXG5pbXBvcnQgeyBOZ1Byb2dyZXNzQ29tcG9uZW50IH0gZnJvbSAnLi9uZy1wcm9ncmVzcy5jb21wb25lbnQnO1xyXG5pbXBvcnQgeyBOZ1Byb2dyZXNzQ29uZmlnLCBDT05GSUcgfSBmcm9tICcuL25nLXByb2dyZXNzLmludGVyZmFjZSc7XHJcblxyXG5ATmdNb2R1bGUoe1xyXG4gIGRlY2xhcmF0aW9uczogW05nUHJvZ3Jlc3NDb21wb25lbnRdLFxyXG4gIGV4cG9ydHM6IFtOZ1Byb2dyZXNzQ29tcG9uZW50XSxcclxuICBpbXBvcnRzOiBbQ29tbW9uTW9kdWxlXVxyXG59KVxyXG5leHBvcnQgY2xhc3MgTmdQcm9ncmVzc01vZHVsZSB7XHJcbiAgc3RhdGljIGZvclJvb3QoY29uZmlnPzogTmdQcm9ncmVzc0NvbmZpZyk6IE1vZHVsZVdpdGhQcm92aWRlcnMge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgbmdNb2R1bGU6IE5nUHJvZ3Jlc3NNb2R1bGUsXHJcbiAgICAgIHByb3ZpZGVyczogW1xyXG4gICAgICAgIHtwcm92aWRlOiBDT05GSUcsIHVzZVZhbHVlOiBjb25maWd9XHJcbiAgICAgIF1cclxuICAgIH07XHJcbiAgfVxyXG59XHJcbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFDQTs7OztJQXdDRSxZQUFZLFlBQThCO3NCQW5DUixFQUFDLE1BQU0sRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLENBQUMsRUFBQzs7OzsyQkFJckMsSUFBSSxPQUFPLEVBQUU7Ozs7c0JBRzFCLElBQUksZUFBZSxDQUFrQixJQUFJLENBQUMsTUFBTSxDQUFDOzs7O3VCQUdoRCxJQUFJLE9BQU8sRUFBb0I7UUEyQnZDLGFBQWEsQ0FBQyxJQUFJLENBQUMsV0FBVyxFQUFFLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxJQUFJLENBQ2hELFFBQVEsQ0FBQyxDQUFDLENBQUMsS0FBSyxFQUFFLE1BQU0s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