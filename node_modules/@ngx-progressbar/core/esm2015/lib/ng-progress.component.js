/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * @license
 * Copyright ngx-progressbar All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/MurhafSousli/ngx-progressbar/blob/master/LICENSE
 */
import { Component, Input, Output, ChangeDetectionStrategy, EventEmitter, ViewEncapsulation } from '@angular/core';
import { NgProgress } from './ng-progress.service';
import { NgProgressRef } from './ng-progress-ref';
import { map } from 'rxjs/operators';
export class NgProgressComponent {
    /**
     * @param {?} _ngProgress
     */
    constructor(_ngProgress) {
        this._ngProgress = _ngProgress;
        /**
         * Creates a new instance if id is not already exists
         */
        this.id = 'root';
        /**
         * Initializes inputs from the global config
         */
        this.spinnerPosition = this._ngProgress.config.spinnerPosition;
        this.direction = this._ngProgress.config.direction;
        this.ease = this._ngProgress.config.ease;
        this.color = this._ngProgress.config.color;
        this.meteor = this._ngProgress.config.meteor;
        this.spinner = this._ngProgress.config.spinner;
        this.thick = this._ngProgress.config.thick;
        this.max = this._ngProgress.config.max;
        this.min = this._ngProgress.config.min;
        this.speed = this._ngProgress.config.speed;
        this.trickleSpeed = this._ngProgress.config.trickleSpeed;
        this.trickleFunc = this._ngProgress.config.trickleFunc;
        this.debounceTime = this._ngProgress.config.debounceTime;
        this.started = new EventEmitter();
        this.completed = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnChanges() {
        if (this.progressRef instanceof NgProgressRef) {
            // Update progress bar config when inputs change
            this.progressRef.setConfig({
                max: (this.max > 0 && this.max <= 100) ? this.max : 100,
                min: (this.min < 100 && this.min >= 0) ? this.min : 0,
                speed: this.speed,
                trickleSpeed: this.trickleSpeed,
                trickleFunc: this.trickleFunc,
                debounceTime: this.debounceTime
            });
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        // Get progress bar service instance
        this.progressRef = this._ngProgress.ref(this.id, {
            max: this.max,
            min: this.min,
            speed: this.speed,
            trickleSpeed: this.trickleSpeed,
            debounceTime: this.debounceTime
        });
        this.state$ = this.progressRef.state$.pipe(map((state) => ({
            active: state.active,
            transform: `translate3d(${state.value}%,0,0)`
        })));
        /** Subscribes to started and completed events when user used them */
        if (this.started.observers.length) {
            this._started$ = this.progressRef.started.subscribe(() => this.started.emit());
        }
        if (this.completed.observers.length) {
            this._completed$ = this.progressRef.completed.subscribe(() => this.completed.emit());
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this._started$) {
            this._started$.unsubscribe();
        }
        if (this._completed$) {
            this._completed$.unsubscribe();
        }
        this._ngProgress.destroy(this.id);
    }
    /**
     * @return {?}
     */
    start() {
        this.progressRef.start();
    }
    /**
     * @return {?}
     */
    complete() {
        this.progressRef.complete();
    }
    /**
     * @param {?=} n
     * @return {?}
     */
    inc(n) {
        this.progressRef.inc(n);
    }
    /**
     * @param {?} n
     * @return {?}
     */
    set(n) {
        this.progressRef.set(n);
    }
    /**
     * @return {?}
     */
    get isStarted() {
        return this.progressRef.isStarted;
    }
}
NgProgressComponent.decorators = [
    { type: Component, args: [{
                selector: 'ng-progress',
                host: {
                    'role': 'progressbar',
                    '[attr.spinnerPosition]': 'spinnerPosition',
                    '[attr.dir]': 'direction',
                    '[attr.thick]': 'thick'
                },
                template: `
    <ng-container *ngIf="state$ | async; let state">
      <div class="ng-progress-bar"
            [class.-active]="state.active"
            [style.transition]="'opacity ' + speed + 'ms ' + ease">
        <div class="ng-bar-placeholder">
          <div class="ng-bar"
                [style.transform]="state.transform"
                [style.backgroundColor]="color"
                [style.transition]="state.active ? 'all ' + speed + 'ms ' + ease : 'none'">
            <div *ngIf="meteor" class="ng-meteor" [style.boxShadow]="'0 0 10px '+ color + ', 0 0 5px ' + color"></div>
          </div>
        </div>
        <div *ngIf="spinner" class="ng-spinner">
          <div class="ng-spinner-icon"
                [style.borderTopColor]="color"
                [style.borderLeftColor]="color"></div>
        </div>
      </div>
    </ng-container>
  `,
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush,
                preserveWhitespaces: false,
                styles: ["ng-progress{z-index:999999;pointer-events:none;position:relative}.ng-progress-bar{z-index:999999;top:0;left:0;width:100%;position:fixed;zoom:1;opacity:0}.ng-progress-bar.-active{opacity:1;transition:none}.ng-bar-placeholder{position:absolute;height:2px;width:100%}.ng-bar{width:100%;height:100%;-webkit-transform:translate(-100%,0,0);transform:translate(-100%,0,0)}.ng-meteor{display:block;position:absolute;width:100px;height:100%;opacity:1}.ng-spinner{display:block;position:fixed;z-index:1031;top:15px}.ng-spinner-icon{width:18px;height:18px;box-sizing:border-box;-webkit-animation:.4s linear infinite spinner-animation;animation:.4s linear infinite spinner-animation;border:2px solid transparent;border-radius:50%}[dir='ltr+'] .ng-meteor,[dir=ltr-] .ng-meteor{-webkit-transform:rotate(3deg);transform:rotate(3deg)}[dir='ltr+'][thick=true] .ng-meteor,[dir=ltr-][thick=true] .ng-meteor{-webkit-transform:rotate(4deg);transform:rotate(4deg)}[dir='ltr+'] .ng-bar,[dir='rtl+'] .ng-bar{margin-left:-100%}[dir='ltr+'] .ng-meteor,[dir='rtl+'] .ng-meteor{right:0}[dir='ltr+'] .ng-meteor,[dir=rtl-] .ng-meteor{top:-3px}[dir='ltr+'][thick=true] .ng-meteor,[dir=rtl-][thick=true] .ng-meteor{top:-4px}[dir='rtl+'] .ng-meteor,[dir=ltr-] .ng-meteor{bottom:-3px}[dir='rtl+'][thick=true] .ng-meteor,[dir=ltr-][thick=true] .ng-meteor{bottom:-4px}[dir='rtl+'] .ng-bar-placeholder,[dir=ltr-] .ng-bar-placeholder{-webkit-transform:rotate(180deg);transform:rotate(180deg)}[dir='rtl+'] .ng-spinner-icon,[dir=ltr-] .ng-spinner-icon{animation-direction:reverse}[dir='rtl+'] .ng-meteor,[dir=rtl-] .ng-meteor{-webkit-transform:rotate(-3deg);transform:rotate(-3deg)}[dir='rtl+'][thick=true] .ng-meteor,[dir=rtl-][thick=true] .ng-meteor{-webkit-transform:rotate(-4deg);transform:rotate(-4deg)}[thick=true] .ng-spinner-icon{width:24px;height:24px;border-width:3px}[thick=true] .ng-bar-placeholder{height:3px}[spinnerPosition=left] .ng-spinner{left:15px;right:unset}[spinnerPosition=right] .ng-spinner{right:15px}@-webkit-keyframes spinner-animation{0%{-webkit-transform:rotate(0);transform:rotate(0)}100%{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}@keyframes spinner-animation{0%{-webkit-transform:rotate(0);transform:rotate(0)}100%{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}"]
            }] }
];
/** @nocollapse */
NgProgressComponent.ctorParameters = () => [
    { type: NgProgress }
];
NgProgressComponent.propDecorators = {
    id: [{ type: Input }],
    spinnerPosition: [{ type: Input }],
    direction: [{ type: Input }],
    ease: [{ type: Input }],
    color: [{ type: Input }],
    meteor: [{ type: Input }],
    spinner: [{ type: Input }],
    thick: [{ type: Input }],
    max: [{ type: Input }],
    min: [{ type: Input }],
    speed: [{ type: Input }],
    trickleSpeed: [{ type: Input }],
    trickleFunc: [{ type: Input }],
    debounceTime: [{ type: Input }],
    started: [{ type: Output }],
    completed: [{ type: Output }]
};
if (false) {
    /** @type {?} */
    NgProgressComponent.prototype._started$;
    /** @type {?} */
    NgProgressComponent.prototype._completed$;
    /**
     * Progress bar worker
     * @type {?}
     */
    NgProgressComponent.prototype.progressRef;
    /**
     * Progress state stream
     * @type {?}
     */
    NgProgressComponent.prototype.state$;
    /**
     * Creates a new instance if id is not already exists
     * @type {?}
     */
    NgProgressComponent.prototype.id;
    /**
     * Initializes inputs from the global config
     * @type {?}
     */
    NgProgressComponent.prototype.spinnerPosition;
    /** @type {?} */
    NgProgressComponent.prototype.direction;
    /** @type {?} */
    NgProgressComponent.prototype.ease;
    /** @type {?} */
    NgProgressComponent.prototype.color;
    /** @type {?} */
    NgProgressComponent.prototype.meteor;
    /** @type {?} */
    NgProgressComponent.prototype.spinner;
    /** @type {?} */
    NgProgressComponent.prototype.thick;
    /** @type {?} */
    NgProgressComponent.prototype.max;
    /** @type {?} */
    NgProgressComponent.prototype.min;
    /** @type {?} */
    NgProgressComponent.prototype.speed;
    /** @type {?} */
    NgProgressComponent.prototype.trickleSpeed;
    /** @type {?} */
    NgProgressComponent.prototype.trickleFunc;
    /** @type {?} */
    NgProgressComponent.prototype.debounceTime;
    /** @type {?} */
    NgProgressComponent.prototype.started;
    /** @type {?} */
    NgProgressComponent.prototype.completed;
    /** @type {?} */
    NgProgressComponent.prototype._ngProgress;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmctcHJvZ3Jlc3MuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6Im5nOi8vQG5neC1wcm9ncmVzc2Jhci9jb3JlLyIsInNvdXJjZXMiOlsibGliL25nLXByb2dyZXNzLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQVFBLE9BQU8sRUFDTCxTQUFTLEVBQ1QsS0FBSyxFQUlMLE1BQU0sRUFDTix1QkFBdUIsRUFDdkIsWUFBWSxFQUNaLGlCQUFpQixFQUNsQixNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sdUJBQXVCLENBQUM7QUFDbkQsT0FBTyxFQUFFLGFBQWEsRUFBRSxNQUFNLG1CQUFtQixDQUFDO0FBR2xELE9BQU8sRUFBRSxHQUFHLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQXFDckMsTUFBTTs7OztJQStCSixZQUFvQixXQUF1QjtRQUF2QixnQkFBVyxHQUFYLFdBQVcsQ0FBWTs7OztrQkFuQjdCLE1BQU07Ozs7K0JBR3lCLElBQUksQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLGVBQWU7eUJBQzVCLElBQUksQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLFNBQVM7b0JBQ2pFLElBQUksQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLElBQUk7cUJBQzNCLElBQUksQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLEtBQUs7c0JBQzNCLElBQUksQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLE1BQU07dUJBQzdCLElBQUksQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLE9BQU87cUJBQ2pDLElBQUksQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLEtBQUs7bUJBQ2hDLElBQUksQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLEdBQUc7bUJBQzNCLElBQUksQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLEdBQUc7cUJBQ3pCLElBQUksQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLEtBQUs7NEJBQ3RCLElB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c2VcclxuICogQ29weXJpZ2h0IG5neC1wcm9ncmVzc2JhciBBbGwgUmlnaHRzIFJlc2VydmVkLlxyXG4gKlxyXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxyXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vZ2l0aHViLmNvbS9NdXJoYWZTb3VzbGkvbmd4LXByb2dyZXNzYmFyL2Jsb2IvbWFzdGVyL0xJQ0VOU0VcclxuICovXHJcblxyXG5pbXBvcnQge1xyXG4gIENvbXBvbmVudCxcclxuICBJbnB1dCxcclxuICBPbkNoYW5nZXMsXHJcbiAgT25EZXN0cm95LFxyXG4gIE9uSW5pdCxcclxuICBPdXRwdXQsXHJcbiAgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksXHJcbiAgRXZlbnRFbWl0dGVyLFxyXG4gIFZpZXdFbmNhcHN1bGF0aW9uXHJcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IE5nUHJvZ3Jlc3MgfSBmcm9tICcuL25nLXByb2dyZXNzLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBOZ1Byb2dyZXNzUmVmIH0gZnJvbSAnLi9uZy1wcm9ncmVzcy1yZWYnO1xyXG5pbXBvcnQgeyBOZ1Byb2dyZXNzU3RhdGUgfSBmcm9tICcuL25nLXByb2dyZXNzLmludGVyZmFjZSc7XHJcbmltcG9ydCB7IE9ic2VydmFibGUsIFN1YnNjcmlwdGlvbn0gZnJvbSAncnhqcyc7XHJcbmltcG9ydCB7IG1hcCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcclxuXHJcbkBDb21wb25lbnQoe1xyXG4gIHNlbGVjdG9yOiAnbmctcHJvZ3Jlc3MnLFxyXG4gIGhvc3Q6IHtcclxuICAgICdyb2xlJzogJ3Byb2dyZXNzYmFyJyxcclxuICAgICdbYXR0ci5zcGlubmVyUG9zaXRpb25dJzogJ3NwaW5uZXJQb3NpdGlvbicsXHJcbiAgICAnW2F0dHIuZGlyXSc6ICdkaXJlY3Rpb24nLFxyXG4gICAgJ1thdHRyLnRoaWNrXSc6ICd0aGljaydcclxuICB9LFxyXG4gIHRlbXBsYXRlOiBgXHJcbiAgICA8bmctY29udGFpbmVyICpuZ0lmPVwic3RhdGUkIHwgYXN5bmM7IGxldCBzdGF0ZVwiPlxyXG4gICAgICA8ZGl2IGNsYXNzPVwibmctcHJvZ3Jlc3MtYmFyXCJcclxuICAgICAgICAgICAgW2NsYXNzLi1hY3RpdmVdPVwic3RhdGUuYWN0aXZlXCJcclxuICAgICAgICAgICAgW3N0eWxlLnRyYW5zaXRpb25dPVwiJ29wYWNpdHkgJyArIHNwZWVkICsgJ21zICcgKyBlYXNlXCI+XHJcbiAgICAgICAgPGRpdiBjbGFzcz1cIm5nLWJhci1wbGFjZWhvbGRlclwiPlxyXG4gICAgICAgICAgPGRpdiBjbGFzcz1cIm5nLWJhclwiXHJcbiAgICAgICAgICAgICAgICBbc3R5bGUudHJhbnNmb3JtXT1cInN0YXRlLnRyYW5zZm9ybVwiXHJcbiAgICAgICAgICAgICAgICBbc3R5bGUuYmFja2dyb3VuZENvbG9yXT1cImNvbG9yXCJcclxuICAgICAgICAgICAgICAgIFtzdHlsZS50cmFuc2l0aW9uXT1cInN0YXRlLmFjdGl2ZSA/ICdhbGwgJyArIHNwZWVkICsgJ21zICcgKyBlYXNlIDogJ25vbmUnXCI+XHJcbiAgICAgICAgICAgIDxkaXYgKm5nSWY9XCJtZXRlb3JcIiBjbGFzcz1cIm5nLW1ldGVvclwiIFtzdHlsZS5ib3hTaGFkb3ddPVwiJzAgMCAxMHB4ICcrIGNvbG9yICsgJywgMCAwIDVweCAnICsgY29sb3JcIj48L2Rpdj5cclxuICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDxkaXYgKm5nSWY9XCJzcGlubmVyXCIgY2xhc3M9XCJuZy1zcGlubmVyXCI+XHJcbiAgICAgICAgICA8ZGl2IGNsYXNzPVwibmctc3Bpbm5lci1pY29uXCJcclxuICAgICAgICAgICAgICAgIFtzdHlsZS5ib3JkZXJUb3BDb2xvcl09XCJjb2xvclwiXHJcbiAgICAgICAgICAgICAgICBbc3R5bGUuYm9yZGVyTGVmdENvbG9yXT1cImNvbG9yXCI+PC9kaXY+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICAgIDwvZGl2PlxyXG4gICAgPC9uZy1jb250YWluZXI+XHJcbiAgYCxcclxuICBzdHlsZVVybHM6IFsnLi9uZy1wcm9ncmVzcy5jb21wb25lbnQuc2NzcyddLFxyXG4gIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXHJcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXHJcbiAgcHJlc2VydmVXaGl0ZXNwYWNlczogZmFsc2VcclxufSlcclxuXHJcbmV4cG9ydCBjbGFzcyBOZ1Byb2dyZXNzQ29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0LCBPbkNoYW5nZXMsIE9uRGVzdHJveSB7XHJcblxyXG4gIHByaXZhdGUgX3N0YXJ0ZWQkOiBTdWJzY3JpcHRpb247XHJcbiAgcHJpdmF0ZSBfY29tcGxldGVkJDogU3Vic2NyaXB0aW9uO1xyXG5cclxuICAvKiogUHJvZ3Jlc3MgYmFyIHdvcmtlciAqL1xyXG4gIHByb2dyZXNzUmVmOiBOZ1Byb2dyZXNzUmVmO1xyXG5cclxuICAvKiogUHJvZ3Jlc3Mgc3RhdGUgc3RyZWFtICovXHJcbiAgc3RhdGUkOiBPYnNlcnZhYmxlPHsgYWN0aXZlOiBib29sZWFuLCB0cmFuc2Zvcm06IHN0cmluZyB9PjtcclxuXHJcbiAgLyoqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2UgaWYgaWQgaXMgbm90IGFscmVhZHkgZXhpc3RzICovXHJcbiAgQElucHV0KCkgaWQgPSAncm9vdCc7XHJcblxyXG4gIC8qKiBJbml0aWFsaXplcyBpbnB1dHMgZnJvbSB0aGUgZ2xvYmFsIGNvbmZpZyAqL1xyXG4gIEBJbnB1dCgpIHNwaW5uZXJQb3NpdGlvbjogJ2xlZnQnIHwgJ3JpZ2h0JyA9IHRoaXMuX25nUHJvZ3Jlc3MuY29uZmlnLnNwaW5uZXJQb3NpdGlvbjtcclxuICBASW5wdXQoKSBkaXJlY3Rpb246ICdsdHIrJyB8ICdsdHItJyB8ICdydGwrJyB8ICdydGwtJyA9IHRoaXMuX25nUHJvZ3Jlc3MuY29uZmlnLmRpcmVjdGlvbjtcclxuICBASW5wdXQoKSBlYXNlOiBzdHJpbmcgPSB0aGlzLl9uZ1Byb2dyZXNzLmNvbmZpZy5lYXNlO1xyXG4gIEBJbnB1dCgpIGNvbG9yOiBzdHJpbmcgPSB0aGlzLl9uZ1Byb2dyZXNzLmNvbmZpZy5jb2xvcjtcclxuICBASW5wdXQoKSBtZXRlb3I6IGJvb2xlYW4gPSB0aGlzLl9uZ1Byb2dyZXNzLmNvbmZpZy5tZXRlb3I7XHJcbiAgQElucHV0KCkgc3Bpbm5lcjogYm9vbGVhbiA9IHRoaXMuX25nUHJvZ3Jlc3MuY29uZmlnLnNwaW5uZXI7XHJcbiAgQElucHV0KCkgdGhpY2s6IGJvb2xlYW4gPSB0aGlzLl9uZ1Byb2dyZXNzLmNvbmZpZy50aGljaztcclxuICBASW5wdXQoKSBtYXg6IG51bWJlciA9IHRoaXMuX25nUHJvZ3Jlc3MuY29uZmlnLm1heDtcclxuICBASW5wdXQoKSBtaW46IG51bWJlciA9IHRoaXMuX25nUHJvZ3Jlc3MuY29uZmlnLm1pbjtcclxuICBASW5wdXQoKSBzcGVlZDogbnVtYmVyID0gdGhpcy5fbmdQcm9ncmVzcy5jb25maWcuc3BlZWQ7XHJcbiAgQElucHV0KCkgdHJpY2tsZVNwZWVkOiBudW1iZXIgPSB0aGlzLl9uZ1Byb2dyZXNzLmNvbmZpZy50cmlja2xlU3BlZWQ7XHJcbiAgQElucHV0KCkgdHJpY2tsZUZ1bmM6IChuOiBudW1iZXIpID0+IG51bWJlciA9IHRoaXMuX25nUHJvZ3Jlc3MuY29uZmlnLnRyaWNrbGVGdW5jO1xyXG4gIEBJbnB1dCgpIGRlYm91bmNlVGltZTogbnVtYmVyID0gdGhpcy5fbmdQcm9ncmVzcy5jb25maWcuZGVib3VuY2VUaW1lO1xyXG4gIEBPdXRwdXQoKSBzdGFydGVkID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gIEBPdXRwdXQoKSBjb21wbGV0ZWQgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcblxyXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgX25nUHJvZ3Jlc3M6IE5nUHJvZ3Jlc3MpIHtcclxuICB9XHJcblxyXG4gIG5nT25DaGFuZ2VzKCkge1xyXG4gICAgaWYgKHRoaXMucHJvZ3Jlc3NSZWYgaW5zdGFuY2VvZiBOZ1Byb2dyZXNzUmVmKSB7XHJcbiAgICAgIC8vIFVwZGF0ZSBwcm9ncmVzcyBiYXIgY29uZmlnIHdoZW4gaW5wdXRzIGNoYW5nZVxyXG4gICAgICB0aGlzLnByb2dyZXNzUmVmLnNldENvbmZpZyh7XHJcbiAgICAgICAgbWF4OiAodGhpcy5tYXggPiAwICYmIHRoaXMubWF4IDw9IDEwMCkgPyB0aGlzLm1heCA6IDEwMCxcclxuICAgICAgICBtaW46ICh0aGlzLm1pbiA8IDEwMCAmJiB0aGlzLm1pbiA+PSAwKSA/IHRoaXMubWluIDogMCxcclxuICAgICAgICBzcGVlZDogdGhpcy5zcGVlZCxcclxuICAgICAgICB0cmlja2xlU3BlZWQ6IHRoaXMudHJpY2tsZVNwZWVkLFxyXG4gICAgICAgIHRyaWNrbGVGdW5jOiB0aGlzLnRyaWNrbGVGdW5jLFxyXG4gICAgICAgIGRlYm91bmNlVGltZTogdGhpcy5kZWJvdW5jZVRpbWVcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBuZ09uSW5pdCgpIHtcclxuICAgIC8vIEdldCBwcm9ncmVzcyBiYXIgc2VydmljZSBpbnN0YW5jZVxyXG4gICAgdGhpcy5wcm9ncmVzc1JlZiA9IHRoaXMuX25nUHJvZ3Jlc3MucmVmKHRoaXMuaWQsIHtcclxuICAgICAgbWF4OiB0aGlzLm1heCxcclxuICAgICAgbWluOiB0aGlzLm1pbixcclxuICAgICAgc3BlZWQ6IHRoaXMuc3BlZWQsXHJcbiAgICAgIHRyaWNrbGVTcGVlZDogdGhpcy50cmlja2xlU3BlZWQsXHJcbiAgICAgIGRlYm91bmNlVGltZTogdGhpcy5kZWJvdW5jZVRpbWVcclxuICAgIH0pO1xyXG4gICAgdGhpcy5zdGF0ZSQgPSB0aGlzLnByb2dyZXNzUmVmLnN0YXRlJC5waXBlKG1hcCgoc3RhdGU6IE5nUHJvZ3Jlc3NTdGF0ZSkgPT4gKHtcclxuICAgICAgYWN0aXZlOiBzdGF0ZS5hY3RpdmUsXHJcbiAgICAgIHRyYW5zZm9ybTogYHRyYW5zbGF0ZTNkKCR7c3RhdGUudmFsdWV9JSwwLDApYFxyXG4gICAgfSkpKTtcclxuICAgIC8qKiBTdWJzY3JpYmVzIHRvIHN0YXJ0ZWQgYW5kIGNvbXBsZXRlZCBldmVudHMgd2hlbiB1c2VyIHVzZWQgdGhlbSAqL1xyXG4gICAgaWYgKHRoaXMuc3RhcnRlZC5vYnNlcnZlcnMubGVuZ3RoKSB7XHJcbiAgICAgIHRoaXMuX3N0YXJ0ZWQkID0gdGhpcy5wcm9ncmVzc1JlZi5zdGFydGVkLnN1YnNjcmliZSgoKSA9PiB0aGlzLnN0YXJ0ZWQuZW1pdCgpKTtcclxuICAgIH1cclxuICAgIGlmICh0aGlzLmNvbXBsZXRlZC5vYnNlcnZlcnMubGVuZ3RoKSB7XHJcbiAgICAgIHRoaXMuX2NvbXBsZXRlZCQgPSB0aGlzLnByb2dyZXNzUmVmLmNvbXBsZXRlZC5zdWJzY3JpYmUoKCkgPT4gdGhpcy5jb21wbGV0ZWQuZW1pdCgpKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIG5nT25EZXN0cm95KCkge1xyXG4gICAgaWYgKHRoaXMuX3N0YXJ0ZWQkKSB7XHJcbiAgICAgIHRoaXMuX3N0YXJ0ZWQkLnVuc3Vic2NyaWJlKCk7XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5fY29tcGxldGVkJCkge1xyXG4gICAgICB0aGlzLl9jb21wbGV0ZWQkLnVuc3Vic2NyaWJlKCk7XHJcbiAgICB9XHJcbiAgICB0aGlzLl9uZ1Byb2dyZXNzLmRlc3Ryb3kodGhpcy5pZCk7XHJcbiAgfVxyXG5cclxuICBzdGFydCgpIHtcclxuICAgIHRoaXMucHJvZ3Jlc3NSZWYuc3RhcnQoKTtcclxuICB9XHJcblxyXG4gIGNvbXBsZXRlKCkge1xyXG4gICAgdGhpcy5wcm9ncmVzc1JlZi5jb21wbGV0ZSgpO1xyXG4gIH1cclxuXHJcbiAgaW5jKG4/OiBudW1iZXIpIHtcclxuICAgIHRoaXMucHJvZ3Jlc3NSZWYuaW5jKG4pO1xyXG4gIH1cclxuXHJcbiAgc2V0KG46IG51bWJlcikge1xyXG4gICAgdGhpcy5wcm9ncmVzc1JlZi5zZXQobik7XHJcbiAgfVxyXG5cclxuICBnZXQgaXNTdGFydGVkKCkge1xyXG4gICAgcmV0dXJuIHRoaXMucHJvZ3Jlc3NSZWYuaXNTdGFydGVkO1xyXG4gIH1cclxufVxyXG4iXX0=