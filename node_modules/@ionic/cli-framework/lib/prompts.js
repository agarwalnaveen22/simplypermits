"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const Debug = require("debug");
const terminal_1 = require("../utils/terminal");
const debug = Debug('ionic:cli-framework:lib:prompts');
let _inquirer;
function loadInquirer() {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        if (!_inquirer) {
            _inquirer = yield Promise.resolve().then(() => require('inquirer'));
        }
        return _inquirer;
    });
}
/**
 * Create a reusable CLI prompt module.
 *
 * A prompt module is a function that generates prompts. A prompt opens an
 * interactive session with the user to gather input. When a prompt is
 * resolved, the user has finished providing input.
 *
 * If non-TTY mode is detected, a system of fallbacks goes into effect:
 *      1. If the question provided 'fallback', the fallback value is resolved.
 *      2. If the prompt module has 'onFallback', it is used to generate a
 *         fallback for the question.
 *      3. If the question provided 'default', the default value is resolved.
 *      4. Finally, a falsy value suitable for the question type is resolved.
 *
 * @param options.interactive Force non-TTY mode by providing 'false'. TTY mode
 *                            cannot be forced if non-TTY mode is detected.
 * @param options.onFallback Generate a non-TTY fallback for a question without
 *                           a 'fallback'.
 */
function createPromptModule({ interactive, onFallback } = {}) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const { createPromptModule: createInquirerPromptModule, ui: { BottomBar } } = yield loadInquirer();
        const promptModule = createInquirerPromptModule();
        const manager = new BottomBarManager({ BottomBar });
        function createPrompter(question) {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                const { fallback } = question, promptQuestion = tslib_1.__rest(question, ["fallback"]);
                if (!terminal_1.TERMINAL_INFO.tty || interactive === false) {
                    if (typeof fallback !== 'undefined') {
                        debug('Answering with provided fallback value for non-tty mode: %o', fallback);
                        return fallback;
                    }
                    else if (onFallback) {
                        const generatedFallback = onFallback(question);
                        if (typeof generatedFallback !== 'undefined') {
                            debug(`Answering with fallback value from 'onFallback' for non-tty mode: %o`, generatedFallback);
                            return generatedFallback;
                        }
                    }
                    if (typeof promptQuestion.default !== 'undefined') {
                        return promptQuestion.default;
                    }
                    if (question.type === 'confirm') {
                        return false;
                    }
                    else if (question.type === 'checkbox') {
                        return [];
                    }
                    return '';
                }
                const name = 'name';
                const prompt = promptModule(Object.assign({}, promptQuestion, { name }));
                const result = (yield prompt)[name];
                if (typeof result === 'undefined' || result === null) {
                    return '';
                }
                if (typeof result !== 'string' && typeof result !== 'boolean' && !Array.isArray(result)) {
                    return String(result);
                }
                return result;
            });
        }
        Object.defineProperties(createPrompter, {
            open: { value: () => manager.open() },
            close: { value: () => manager.close() },
            output: { value: manager },
        });
        return createPrompter;
    });
}
exports.createPromptModule = createPromptModule;
function createPromptChoiceSeparator() {
    if (!_inquirer) {
        throw new Error(`Prompt module not initialized. Call 'createPromptModule' first.`);
    }
    return new _inquirer.Separator();
}
exports.createPromptChoiceSeparator = createPromptChoiceSeparator;
class BottomBarManager {
    constructor({ BottomBar, input = process.stdin, output = process.stdout }) {
        this.BottomBar = BottomBar;
        this.rawinput = input;
        this.rawoutput = output;
    }
    get stream() {
        const bottomBar = this.get();
        return bottomBar.log;
    }
    redrawLine(msg = '') {
        const bottomBar = this.get();
        bottomBar.updateBottomBar(msg);
    }
    get() {
        if (!this.bottomBar) {
            this.bottomBar = new this.BottomBar({ input: this.rawinput, output: this.rawoutput });
            try {
                // the mute() call appears to be necessary, otherwise when answering
                // inquirer prompts upon pressing enter, a copy of the prompt is
                // printed to the screen and looks gross
                this.bottomBar.rl.output.mute();
            }
            catch (e) {
                debug('Error while muting bottomBar output: %o', e);
            }
        }
        return this.bottomBar;
    }
    open() {
        this.get();
    }
    close() {
        if (this.bottomBar) {
            // instantiating inquirer.ui.BottomBar hangs, so when close() is called,
            // close BottomBar streams
            this.bottomBar.close();
            this.bottomBar = undefined;
        }
    }
}
